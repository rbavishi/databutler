import collections
from typing import (
    List,
    Dict,
    Optional,
    Hashable,
    Iterator,
    Any,
    Deque,
    Set,
    Type,
    Callable,
)

import attr

from databutler.pat import astlib
from databutler.pat.analysis.clock import LogicalClock
from databutler.pat.analysis.hierarchical_trace.core import (
    TraceItem,
    TraceEvent,
    DefEvent,
    TraceItemType,
)
from databutler.pat.analysis.instrumentation import (
    StmtCallbacksGenerator,
    ExprCallbacksGenerator,
    StmtCallback,
    ExprCallback,
    ExprWrappersGenerator,
    ExprWrapper,
)


@attr.s(cmp=False, repr=False)
class TemporaryVariablesGenerator:
    prefix: str = attr.ib(default="_htrace_temp_var")

    #  Internal Stuff
    _ctr: int = attr.ib(init=False, default=0)

    def get_new_var(self):
        self._ctr += 1
        return f"{self.prefix}{self._ctr}"


@attr.s(cmp=False, repr=False)
class ValueKeepAliveAgent(ExprWrappersGenerator):
    """
    Store a reference to every object in order to keep it safe from the GC.
    This helps avoid clashes of object IDs.
    """

    _ref_map: Dict[int, Any] = attr.ib(factory=dict)

    def reset(self):
        self._ref_map.clear()

    def cleanup(self):
        self._ref_map.clear()

    def gen_expr_wrappers(
        self, ast_root: astlib.AstNode
    ) -> Dict[astlib.BaseExpression, List[ExprWrapper]]:
        wrappers = {}
        for expr in self.iter_valid_exprs(ast_root):
            wrappers[expr] = [
                ExprWrapper(callable=self._keep_alive, name=self.gen_wrapper_id())
            ]

        return wrappers

    def _keep_alive(self, value):
        self._ref_map[id(value)] = value
        return value


@attr.s(cmp=False, repr=False)
class TraceItemsCollector:
    """
    Simply stores the trace items generated by various instrumentation.
    """

    _items: List[TraceItem] = attr.ib(init=False, default=None)
    _last_item_dict: Dict[astlib.AstNode, TraceItem] = attr.ib(init=False, default=None)
    _is_in_progress: Set[TraceItem] = attr.ib(init=False, default=None)
    _in_progress_items_stack: Deque[TraceItem] = attr.ib(init=False, default=None)
    _in_progress_items_stack_per_node: Dict[astlib.AstNode, Deque[TraceItem]] = attr.ib(
        init=False, default=None
    )

    def __attrs_post_init__(self):
        self.reset()

    def reset(self):
        self._items = []
        self._last_item_dict = {}
        self._is_in_progress = set()
        self._in_progress_items_stack = collections.deque()
        self._in_progress_items_stack_per_node = collections.defaultdict(
            collections.deque
        )

    def add_item(self, trace_item: TraceItem):
        self._items.append(trace_item)
        self._last_item_dict[trace_item.ast_node] = trace_item

        if trace_item in self._is_in_progress:
            #  Discard all the items up until trace_item
            while True:
                cur = self._in_progress_items_stack.pop()
                self._in_progress_items_stack_per_node[cur.ast_node].pop()
                self._is_in_progress.discard(cur)
                if cur is trace_item:
                    break

        par_item = None
        if len(self._in_progress_items_stack) > 0:
            par_item = self._in_progress_items_stack[-1]

        trace_item.par_item = par_item

    def add_in_progress_item(self, trace_item: TraceItem):
        self._is_in_progress.add(trace_item)
        self._in_progress_items_stack.append(trace_item)
        self._in_progress_items_stack_per_node[trace_item.ast_node].append(trace_item)

    def get_last_item_for_node(self, node: astlib.AstNode) -> Optional[TraceItem]:
        return self._last_item_dict.get(node, None)

    def get_last_in_progress_item_for_node(
        self, node: astlib.AstNode
    ) -> Optional[TraceItem]:
        s = self._in_progress_items_stack_per_node[node]
        if len(s) > 0:
            return s[-1]
        else:
            return None

    def get_last_in_progress_item(self) -> Optional[TraceItem]:
        if len(self._in_progress_items_stack) > 0:
            return self._in_progress_items_stack[-1]
        else:
            return None

    def get_items(self) -> List[TraceItem]:
        return self._items[:]


@attr.s(cmp=False, repr=False)
class TraceEventsCollector:
    """
    Simply stores the events generated by various instrumentation.
    """

    #  Internal Stuff
    _events: List[TraceEvent] = attr.ib(init=False, default=None)
    _last_event_for_def: Dict[Hashable, DefEvent] = attr.ib(init=False, default=None)
    _event_handlers: Dict[Type[TraceEvent], List[Callable]] = attr.ib(
        init=False, default=None
    )

    def __attrs_post_init__(self):
        self.reset()
        self.add_event = self._add_event_without_handlers

    def reset(self):
        self._events = []
        self._last_event_for_def = {}

    def add_event(self, event: TraceEvent, **kwargs) -> None:
        pass

    def _add_event_without_handlers(self, event: TraceEvent, **kwargs):
        self._events.append(event)
        if isinstance(event, DefEvent):
            self._last_event_for_def[event.def_key] = event

    def _add_event_with_handlers(self, event: TraceEvent, **kwargs):
        #  We have a special version with handlers support to improve performance.
        self._events.append(event)
        if isinstance(event, DefEvent):
            self._last_event_for_def[event.def_key] = event

        for h in self._event_handlers[type(event)]:
            h(event, **kwargs)

    def get_last_event_for_def(self, def_key: Hashable) -> Optional[DefEvent]:
        return self._last_event_for_def.get(def_key, None)

    def get_events(self):
        return self._events[:]

    def install_event_handlers(self, handlers: Dict[Type[TraceEvent], List[Callable]]):
        self._event_handlers = handlers
        self.add_event = self._add_event_with_handlers


@attr.s(cmp=False, repr=False)
class TraceItemGenerator(
    StmtCallbacksGenerator, ExprCallbacksGenerator, ExprWrappersGenerator
):
    """
    In charge of incrementing the clock, and recording trace items.
    """

    clock: LogicalClock = attr.ib()
    collector: TraceItemsCollector = attr.ib()

    #  Internal Stuff
    _pending_items: Dict[astlib.AstNode, TraceItem] = attr.ib(init=False, default=None)
    _start_time_dict: Dict[astlib.AstNode, int] = attr.ib(init=False, default=None)
    _scope_id_dict: Dict[astlib.AstNode, astlib.ScopeId] = attr.ib(
        init=False, default=None
    )

    def __attrs_post_init__(self):
        self.reset()

    def reset(self):
        self._pending_items = {}
        self._scope_id_dict = {}

    def preprocess(self, ast_root: astlib.AstNode):
        self._scope_id_dict.update(astlib.get_scope_id_mapping(ast_root))

    def gen_stmt_callbacks(
        self, ast_root: astlib.AstNode
    ) -> Dict[astlib.AstStatementT, List[StmtCallback]]:
        callbacks: Dict[
            astlib.AstStatementT, List[StmtCallback]
        ] = collections.defaultdict(list)

        for stmt in self.iter_stmts(ast_root):
            callbacks[stmt].extend(self._gen_callbacks_for_stmt(stmt))

        return callbacks

    def gen_expr_callbacks(
        self, ast_root: astlib.AstNode
    ) -> Dict[astlib.BaseExpression, List[ExprCallback]]:
        callbacks: Dict[
            astlib.BaseExpression, List[ExprCallback]
        ] = collections.defaultdict(list)

        for expr in self.iter_valid_exprs(ast_root):
            callbacks[expr].extend(self._gen_callbacks_for_expr(expr))

        return callbacks

    def gen_expr_wrappers(
        self, ast_root: astlib.AstNode
    ) -> Dict[astlib.BaseExpression, List[ExprWrapper]]:
        wrappers: Dict[
            astlib.BaseExpression, List[ExprWrapper]
        ] = collections.defaultdict(list)

        for expr in self.iter_valid_exprs(ast_root):
            wrappers[expr].extend(self._gen_wrappers_for_expr(expr))

        return wrappers

    def _gen_callbacks_for_stmt(self, stmt: astlib.AstStatementT) -> List[StmtCallback]:
        if isinstance(
            stmt,
            (astlib.Return, astlib.Continue, astlib.Break, astlib.Raise, astlib.Assert),
        ):
            return []

        scope_id: astlib.ScopeId = self._scope_id_dict[stmt]
        still_pending: bool = False

        def callback_pre():
            """
            Add a pending item for this statement.
            :return:
            """
            nonlocal still_pending
            start_time = self.clock.get_time()
            self.clock.increment(step=1)

            trace_item = TraceItem(
                start_time=start_time,
                end_time=-1,  # will be patched later
                ast_node=stmt,
                scope_id=scope_id,
                item_type=TraceItemType.STMT,
            )

            self._pending_items[stmt] = trace_item
            self.collector.add_in_progress_item(trace_item)
            still_pending = True

        def callback_post():
            """
            Finalize the pending item for this statement.
            :return:
            """
            nonlocal still_pending
            end_time = self.clock.increment(step=1)
            trace_item = self._pending_items[stmt]
            trace_item.end_time = end_time

            self.collector.add_item(trace_item)
            still_pending = False

        def callback_mandatory_post():
            """
            Finalize the pending item for this statement.
            :return:
            """
            if still_pending:
                end_time = self.clock.increment(step=1)
                trace_item = self._pending_items[stmt]
                trace_item.end_time = end_time

                self.collector.add_item(trace_item)

        return [
            #  The priorities make sure 'pre' is the last to execute, and 'post' is first to execute.
            StmtCallback(
                callable=callback_pre,
                name=self.gen_stmt_callback_id(),
                position="pre",
                arg_str="",
                priority=-1000,
            ),
            StmtCallback(
                callable=callback_post,
                name=self.gen_stmt_callback_id(),
                position="post",
                arg_str="",
                mandatory=False,
                priority=1000,
            ),
            StmtCallback(
                callable=callback_mandatory_post,
                name=self.gen_stmt_callback_id(),
                position="post",
                arg_str="",
                mandatory=True,
                priority=1000,
            ),
        ]

    def _gen_callbacks_for_expr(
        self, expr: astlib.BaseExpression
    ) -> List[ExprCallback]:
        scope_id: astlib.ScopeId = self._scope_id_dict[expr]

        def callback_pre():
            """
            Add a pending item for this expression.
            :return:
            """
            start_time = self.clock.get_time()
            self.clock.increment(step=1)

            trace_item = TraceItem(
                start_time=start_time,
                end_time=-1,  # will be patched later in post
                ast_node=expr,
                scope_id=scope_id,
                item_type=TraceItemType.EXPR,
                obj_id=-1,  # will be patched later in wrapper
            )

            self._pending_items[expr] = trace_item
            self.collector.add_in_progress_item(trace_item)

        def callback_post():
            """
            Finalize the pending item for this expression.
            :return:
            """
            end_time = self.clock.increment(step=1)
            trace_item = self._pending_items[expr]
            trace_item.end_time = end_time

            self.collector.add_item(trace_item)

        return [
            #  The priorities make sure 'pre' is the last to execute, and 'post' is first to execute.
            ExprCallback(
                callable=callback_pre,
                name=self.gen_expr_callback_id(),
                position="pre",
                arg_str="",
                priority=-1000,
            ),
            ExprCallback(
                callable=callback_post,
                name=self.gen_expr_callback_id(),
                position="post",
                arg_str="",
                priority=1000,
            ),
        ]

    def _gen_wrappers_for_expr(self, expr: astlib.BaseExpression) -> List[ExprWrapper]:
        def wrapper(value):
            """
            Record the obj ID in the pending item.
            :param value:
            :return:
            """
            trace_item = self._pending_items[expr]
            trace_item.obj_id = id(value)

            return value

        return [ExprWrapper(callable=wrapper, name=self.gen_wrapper_id())]


def iter_potentially_modified_subexprs(
    expr: astlib.BaseExpression,
) -> Iterator[astlib.BaseExpression]:
    if isinstance(expr, (astlib.Subscript, astlib.Attribute)):
        yield expr.value
        yield from iter_potentially_modified_subexprs(expr.value)

    elif isinstance(expr, astlib.Name):
        return

    else:
        for c in astlib.children(expr):
            if isinstance(c, astlib.BaseExpression):
                yield c
                yield from iter_potentially_modified_subexprs(c)
